/*
 * IdeaVim - Vim emulator for IDEs based on the IntelliJ platform
 * Copyright (C) 2003-2016 The IdeaVim authors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package com.maddyhome.idea.vim.option;

import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.extensions.Extensions;
import com.maddyhome.idea.vim.VimPlugin;
import com.maddyhome.idea.vim.ex.ExOutputModel;
import com.maddyhome.idea.vim.extension.VimExtension;
import com.maddyhome.idea.vim.helper.EditorHelper;
import com.maddyhome.idea.vim.helper.MessageHelper;
import com.maddyhome.idea.vim.helper.Msg;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;

/**
 * Maintains the set of support options
 */
public class Options {
  public static final String RELATIVE_NUMBER = "relativenumber";
  public static final String NUMBER = "number";
  public static final String CLIPBOARD = "clipboard";
  public static final String INCREMENTAL_SEARCH = "incsearch";
  public static final String TIMEOUT = "timeout";
  public static final String VIMINFO = "viminfo";
  public static final String GVIM_PATH = "gvimpath";

  /**
   * Gets the singleton instance of the options
   *
   * @return The singleton
   */
  public synchronized static Options getInstance() {
    if (ourInstance == null) {
      ourInstance = new Options();
    }
    return ourInstance;
  }

  /**
   * Convenience method to check if a boolean option is set or not
   *
   * @param name The name of the option to check
   * @return True if set, false if not set or name is invalid or not a boolean option
   */
  public boolean isSet(String name) {
    final Option opt = getOption(name);
    return opt != null && opt instanceof ToggleOption && ((ToggleOption)opt).getValue();
  }

  /**
   * Gets an option by the supplied name or short name.
   *
   * @param name The option's name or short name
   * @return The option with the given name or short name. null if there is no such option
   */
  public Option getOption(String name) {
    Option res = options.get(name);
    if (res == null) {
      res = abbrevs.get(name);
    }

    return res;
  }

  @Nullable
  public NumberOption getNumberOption(@NotNull String name) {
    final Option option = getOption(name);
    if (option instanceof NumberOption) {
      return (NumberOption)option;
    }
    return null;
  }

  @Nullable
  public ListOption getListOption(@NotNull String name) {
    final Option option = getOption(name);
    if (option instanceof ListOption) {
      return (ListOption)option;
    }
    return null;
  }

  /**
   * Gets all options
   *
   * @return All options
   */
  @NotNull
  Collection<Option> allOptions() {
    return options.values();
  }

  /**
   * Gets only options that have values different from their default values
   *
   * @return The set of changed options
   */
  @NotNull
  Collection<Option> changedOptions() {
    ArrayList<Option> res = new ArrayList<Option>();
    for (Option option : options.values()) {
      if (!option.isDefault()) {
        res.add(option);
      }
    }

    return res;
  }

  /**
   * This parses a set of :set commands. The following types of commands are supported:
   * <ul>
   * <li>:set - show all changed options</li>
   * <li>:set all - show all options</li>
   * <li>:set all& - reset all options to default values</li>
   * <li>:set {option} - set option of boolean, display others</li>
   * <li>:set {option}? - display option</li>
   * <li>:set no{option} - reset boolean option</li>
   * <li>:set inv{option} - toggle boolean option</li>
   * <li>:set {option}! - toggle boolean option</li>
   * <li>:set {option}& - set option to default</li>
   * <li>:set {option}={value} - set option to new value</li>
   * <li>:set {option}:{value} - set option to new value</li>
   * <li>:set {option}+={value} - append or add to option value</li>
   * <li>:set {option}-={value} - remove or subtract from option value</li>
   * <li>:set {option}^={value} - prepend or multiply option value</li>
   * </ul>
   *
   * @param editor    The editor the command was entered for, null if no editor - reading .ideavimrc
   * @param args      The :set command arguments
   * @param failOnBad True if processing should stop when a bad argument is found, false if a bad argument is simply
   *                  skipped and processing continues.
   * @return True if no errors were found, false if there were any errors
   */
  public boolean parseOptionLine(@Nullable Editor editor, @NotNull String args, boolean failOnBad) {
    // No arguments so we show changed values
    if (args.length() == 0) {
      showOptions(editor, changedOptions(), true);

      return true;
    }
    // Arg is all so show all options
    else if (args.equals("all")) {
      showOptions(editor, allOptions(), true);

      return true;
    }
    // Reset all options to default
    else if (args.equals("all&")) {
      resetAllOptions();

      return true;
    }

    // We now have 1 or more option operators separator by spaces
    String error = null;
    String token = null;
    StringTokenizer tokenizer = new StringTokenizer(args);
    ArrayList<Option> toShow = new ArrayList<Option>();
    while (tokenizer.hasMoreTokens()) {
      token = tokenizer.nextToken();
      // See if a space has been backslashed, if no get the rest of the text
      while (token.endsWith("\\")) {
        token = token.substring(0, token.length() - 1) + ' ';
        if (tokenizer.hasMoreTokens()) {
          token += tokenizer.nextToken();
        }
      }

      // Print the value of an option
      if (token.endsWith("?")) {
        String option = token.substring(0, token.length() - 1);
        Option opt = getOption(option);
        if (opt != null) {
          toShow.add(opt);
        }
        else {
          error = Msg.unkopt;
        }
      }
      // Reset a boolean option
      else if (token.startsWith("no")) {
        String option = token.substring(2);
        Option opt = getOption(option);
        if (opt != null) {
          if (opt instanceof ToggleOption) {
            ((ToggleOption)opt).reset();
          }
          else {
            error = Msg.e_invarg;
          }
        }
        else {
          error = Msg.unkopt;
        }
      }
      // Toggle a boolean option
      else if (token.startsWith("inv")) {
        String option = token.substring(3);
        Option opt = getOption(option);
        if (opt != null) {
          if (opt instanceof ToggleOption) {
            ((ToggleOption)opt).toggle();
          }
          else {
            error = Msg.e_invarg;
          }
        }
        else {
          error = Msg.unkopt;
        }
      }
      // Toggle a boolean option
      else if (token.endsWith("!")) {
        String option = token.substring(0, token.length() - 1);
        Option opt = getOption(option);
        if (opt != null) {
          if (opt instanceof ToggleOption) {
            ((ToggleOption)opt).toggle();
          }
          else {
            error = Msg.e_invarg;
          }
        }
        else {
          error = Msg.unkopt;
        }
      }
      // Reset option to default
      else if (token.endsWith("&")) {
        String option = token.substring(0, token.length() - 1);
        Option opt = getOption(option);
        if (opt != null) {
          opt.resetDefault();
        }
        else {
          error = Msg.unkopt;
        }
      }
      // This must be one of =, :, +=, -=, or ^=
      else {
        // Look for the = or : first
        int eq = token.indexOf('=');
        if (eq == -1) {
          eq = token.indexOf(':');
        }
        // No operator so only the option name was given
        if (eq == -1) {
          Option opt = getOption(token);
          if (opt != null) {
            // Valid option so set booleans or display others
            if (opt instanceof ToggleOption) {
              ((ToggleOption)opt).set();
            }
            else {
              toShow.add(opt);
            }
          }
          else {
            error = Msg.unkopt;
          }
        }
        // We have an operator
        else {
          // Make sure there is an option name
          if (eq > 0) {
            // See if an operator before the equal sign
            char op = token.charAt(eq - 1);
            int end = eq;
            if ("+-^".indexOf(op) != -1) {
              end--;
            }
            // Get option name and value after operator
            String option = token.substring(0, end);
            String value = token.substring(eq + 1);
            Option opt = getOption(option);
            if (opt != null) {
              // If not a boolean
              if (opt instanceof TextOption) {
                TextOption to = (TextOption)opt;
                boolean res;
                switch (op) {
                  case '+':
                    res = to.append(value);
                    break;
                  case '-':
                    res = to.remove(value);
                    break;
                  case '^':
                    res = to.prepend(value);
                    break;
                  default:
                    res = to.set(value);
                }
                if (!res) {
                  error = Msg.e_invarg;
                }
              }
              // boolean option - no good
              else {
                error = Msg.e_invarg;
              }
            }
            else {
              error = Msg.unkopt;
            }
          }
          else {
            error = Msg.unkopt;
          }
        }
      }

      if (failOnBad && error != null) {
        break;
      }
    }

    // Now show all options that were individually requested
    if (toShow.size() > 0) {
      showOptions(editor, toShow, false);
    }

    if (editor != null && error != null) {
      VimPlugin.showMessage(MessageHelper.message(error, token));
      VimPlugin.indicateError();
    }

    return error == null;
  }

  /**
   * Resets all options to their default value
   */
  public void resetAllOptions() {
    Collection<Option> opts = allOptions();
    for (Option option : opts) {
      option.resetDefault();
    }
  }

  /**
   * Shows the set of options
   *
   * @param editor    The editor to show them in - if null, this is aborted
   * @param opts      The list of options to display
   * @param showIntro True if intro is displayed, false if not
   */
  private void showOptions(@Nullable Editor editor, @NotNull Collection<Option> opts, boolean showIntro) {
    if (editor == null) {
      return;
    }

    ArrayList<Option> cols = new ArrayList<Option>();
    ArrayList<Option> extra = new ArrayList<Option>();
    for (Option option : opts) {
      if (option.toString().length() > 19) {
        extra.add(option);
      }
      else {
        cols.add(option);
      }
    }

    Collections.sort(cols, new Option.NameSorter<Option>());
    Collections.sort(extra, new Option.NameSorter<Option>());

    String pad = "                    ";
    int width = EditorHelper.getScreenWidth(editor);
    if (width < 20) {
      width = 80;
    }
    int colCount = width / 20;
    int height = (int)Math.ceil((double)cols.size() / (double)colCount);
    int empty = cols.size() % colCount;
    empty = empty == 0 ? colCount : empty;

    if (logger.isDebugEnabled()) {
      logger.debug("width=" + width);
      logger.debug("colCount=" + colCount);
      logger.debug("height=" + height);
    }

    final StringBuilder res = new StringBuilder();
    if (showIntro) {
      res.append("--- Options ---\n");
    }
    for (int h = 0; h < height; h++) {
      for (int c = 0; c < colCount; c++) {
        if (h == height - 1 && c >= empty) {
          break;
        }

        int pos = c * height + h;
        if (c > empty) {
          pos -= c - empty;
        }

        Option opt = cols.get(pos);
        String val = opt.toString();
        res.append(val);
        res.append(pad.substring(0, 20 - val.length()));
      }
      res.append("\n");
    }

    for (Option opt : extra) {
      String val = opt.toString();
      int seg = (val.length() - 1) / width;
      for (int j = 0; j <= seg; j++) {
        res.append(val.substring(j * width, Math.min(j * width + width, val.length())));
        res.append("\n");
      }
    }

    ExOutputModel.getInstance(editor).output(res.toString());
  }

  /**
   * Create all the options
   */
  private Options() {
    createDefaultOptions();
  }

  /**
   * Creates all the supported options
   */
  private void createDefaultOptions() {
    addOption(new ToggleOption("digraph", "dg", false));
    addOption(new ToggleOption("gdefault", "gd", false));
    addOption(new NumberOption("history", "hi", 20, 1, Integer.MAX_VALUE));
    addOption(new ToggleOption("hlsearch", "hls", false));
    addOption(new ToggleOption("ignorecase", "ic", false));
    addOption(new ListOption("matchpairs", "mps", new String[]{"(:)", "{:}", "[:]"}, ".:."));
    addOption(new ToggleOption("more", "more", true));
    addOption(new BoundListOption("nrformats", "nf", new String[]{"octal", "hex"}, new String[]{"octal", "hex", "alpha"}));
    addOption(new NumberOption("scroll", "scr", 0));
    addOption(new NumberOption("scrolljump", "sj", 1));
    addOption(new NumberOption("scrolloff", "so", 0));
    addOption(new BoundStringOption("selection", "sel", "inclusive", new String[]{"old", "inclusive", "exclusive"}));
    addOption(new ToggleOption("showmode", "smd", false));
    addOption(new NumberOption("sidescroll", "ss", 0));
    addOption(new NumberOption("sidescrolloff", "siso", 0));
    addOption(new ToggleOption("smartcase", "scs", false));
    addOption(new NumberOption("timeoutlen", "tm", 1000, -1, Integer.MAX_VALUE));
    addOption(new NumberOption("undolevels", "ul", 1000, -1, Integer.MAX_VALUE));
    addOption(new ToggleOption("visualbell", "vb", false));
    addOption(new ToggleOption("wrapscan", "ws", true));
    addOption(new ToggleOption(NUMBER, "nu", false));
    addOption(new ToggleOption(RELATIVE_NUMBER, "rnu", false));
    addOption(new ListOption(CLIPBOARD, "cb", new String[]{"autoselect,exclude:cons\\|linux"}, null));
    addOption(new ToggleOption(INCREMENTAL_SEARCH, "is", false));
    addOption(new ToggleOption(TIMEOUT, "to", true));
    addOption(new ListOption(VIMINFO, "vi", new String[]{"'100", "<50", "s10", "h"}, null));
    addOption(new StringOption(GVIM_PATH, "gvpath", ""));

    registerExtensionOptions();
  }

  private void registerExtensionOptions() {
    for (VimExtension extension : Extensions.getExtensions(VimExtension.EP_NAME)) {
      final String name = extension.getName();
      final ToggleOption option = new ToggleOption(name, name, false);
      option.addOptionChangeListener(new OptionChangeListener() {
        @Override
        public void valueChange(OptionChangeEvent event) {
          for (VimExtension extension : Extensions.getExtensions(VimExtension.EP_NAME)) {
            if (name.equals(extension.getName())) {
              if (Options.getInstance().isSet(name)) {
                extension.init();
                logger.info("IdeaVim extension '" + name + "' initialized");
              }
              else {
                extension.dispose();
              }
            }
          }
        }
      });
      addOption(option);
    }
  }

  private void addOption(@NotNull Option option) {
    options.put(option.getName(), option);
    abbrevs.put(option.getAbbreviation(), option);
  }

  @NotNull private final HashMap<String, Option> options = new HashMap<String, Option>();
  @NotNull private final HashMap<String, Option> abbrevs = new HashMap<String, Option>();

  private static Options ourInstance;

  private static final Logger logger = Logger.getInstance(Options.class.getName());
}
